<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" type="text/css" href="SlimeArena.css">
	<style>
	* {
		padding:0px;
	}
	body{
		background-color:black;
	}
	#gameDiv{
		margin-left:auto;
		margin-right:auto;
		width:1200px;
	}
	#gameTable{
		width:1200px;
		height:600px;
	}7
	#leftTable, #rightTable{
		width:100%;
		height:100%;
		text-align:center
	}
	#gameTableRight{
		vertical-align:top;
		height:100%;
	}
	#leftTableHeader,#leftTableFooter,#rightTableHeader,#rightTableFooter{
		height:50px;
	}
	#gameTableLeft, #gameTableRight{
		vertical-align:center;
		text-align:center;
		background-color:#202020;
		border: 1px solid black;
		border-collapse: separate;
		border-spacing: 15px;
	}
	#rightTableMenu{	
		width:100%;
	}
	#rightTableMenu td{
		text-align:center;
		background-color:cyan;
		border: 1px solid black;
	}
	#rightTableMenu td:hover{
		text-align:center;
		background-color:red;
		border: 1px solid black;
	}
	#rightTableMenuBody{
		text-align:center;
	}
	#rightTableBody{		
		vertical-align:top;
	}
	#Menu td{
	}
	#Menu tr{
		border:1px solid black;
		padding:0px;
	}
	#Menu{
		border-collapse: collapse;
		margin-top:0px;
		margin-bottom:0px;
		display:block;
	}
	.MenuHead h3{
		padding:0px;
		margin:0px;
	}
	.Menu1{
		background-color:#083a40;
		color:#209080;
	}
	.Menu2{
		background-color:#106060;
		color:#40b0a0;
	}
	.Menu3{
		background-color:#209080;	
		color:#70e0d0;
	}
	.MenuBody{
		visibility:collapse;
	}
	.MenuHead td{
		max-height:10px;
		padding:0px 10px;
	}
	.MenuBody td{
		display:block;
		padding:0px 20px;
		vertical-align:top;
		min-height:525px;
		max-height:525px;
		overflow:auto;
	}
	#actorInfo td{
		width:100px;
	}
	body{
		overflow:hidden;
	}
	</style>
</head>
<body onload="initGame(); " onResize = "document.getElementById('gameDiv').width = window.innerWidth; document.getElementById('gameDiv').height = window.innerHeight;">
	<div id="gameDiv">
	 <table id="gameTable">
	  <tr>
	   <td id="gameTableLeft" width="70%">
		<table id="leftTable">
		 <tr><td id="leftTableHeader">Header</td></tr>
		 <tr>
		  <td id="leftTableBody">
		   <canvas id="myCanvas" style="border:1px solid #d3d3d3; background-color:black;">
		    Your browser does not support the HTML5 canvas tag.
		   </canvas>
		  </td>
		 </tr>
		 <tr><td id="leftTableFooter">Footer</td></tr>
		</table>
	   </td>
	   <td id="gameTableRight" width="30%">	
		  <table id="Menu">
			<tr class="MenuHead Menu1" id="MenuHead1" onClick="openCard('MenuBody1')">
				<td><h3>Actor Info</h3></td>
			</tr>
			<tr class="MenuBody Menu1" id="MenuBody1">
				<td><p id="actorInfo"></p></td>
			</tr>
			<tr class="MenuHead Menu2" id="MenuHead2" onClick="openCard('MenuBody2')">
				<td>
					<h3>Debug Info</h3>
				</td>
			</tr>
			<tr class="MenuBody Menu2" id="MenuBody2">
				<td><p id="debugInfo"></p></td>
			</tr>
			<tr class="MenuHead Menu3" id="MenuHead3" onClick="openCard('MenuBody3')">
				<td>
					<h3>TileMap Info</h3>
				</td>
			</tr>
			<tr class="MenuBody Menu3" id="MenuBody3">
				<td>
					<p id="tileMapInfo">
						Image to use:<br>
						<img id="tileset" src="data:image/png;base64,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" alt="TileMap" >
					</p>
				</td>
			</tr>
		</table>
       </td>
	  </tr>
	 </table>
	</div>
	
	
	<script id="Engine.vp">	
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////// CORE ENGINE CODE BEYOND THIS POINT DANGER DANGER MR BOBINSON //////////////////////////////////////////////////////////////// 
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		/////	CORE ENGINE CLASS DEFINITIONS	/////
		class JSGEactorEngine{
			constructor(){
				this.player = null;
				this.actors = new Array()
				this.friendlies = new Array()
				this.enemies = new Array()
				this.actorStatus = ""
			}
			doAction(act, actor){
				var targetX = actor.x
				var targetY = actor.y
				var targetZ = actor.z
				switch(actor.dir){
					case 0: break;
					case 1: targetY++;break; 
					case 2: targetX--;break;
					case 3: targetY--;break;
					case 4: targetX++;break;
				}
				switch(act[0]){
					case "Fire":
						actor.fireAction();
						break;
					
				}
				
			}
			doMove(dir, actor){
				var oldX = actor.x
				var oldY = actor.y
				var oldZ = actor.z
				if(actor.canMove){
					switch(dir[0]){
						
					case "Up":
						if(mapEngine.boundaryCheck(actor.x,actor.y-1, actor.z)){
							if(mapEngine.collisionCheck(actor.x,actor.y-1, actor.z,actor)){
								oldY = actor.y
								actor.y--;
								mapEngine.transposeAtom(actor.x,oldY,actor.z,actor)
							}
						}
						else{
							if(wrap){
								if(mapEngine.boundaryCheck(actor.x, mapEngine.map[0].length, actor.z)){
									if(mapEngine.collisionCheck(actor.x, mapEngine.map[0].length, actor.z,actor)){
										oldY = actor.y
										actor.y=mapEngine.map[0].length-1;
										mapEngine.transposeAtom(actor.x,oldY,actor.z,actor)
									}
								}
							}
						}		
						actor.dir = 1
						break;
					case "Down":
						if(mapEngine.boundaryCheck(actor.x,actor.y+1, actor.z) ){
							if(mapEngine.collisionCheck(actor.x,actor.y+1, actor.z,actor)){
								oldY = actor.y
								actor.y++;
								mapEngine.transposeAtom(actor.x,oldY,actor.z,actor)
							}
						}
						else{
							if(wrap){
								if(mapEngine.boundaryCheck(actor.x, 0, actor.z)){
									if(mapEngine.collisionCheck(actor.x, 0, actor.z,actor)){
										oldY = actor.y
										actor.y = 0;
										mapEngine.transposeAtom(actor.x,oldY,actor.z,actor)
									}
								}
							}
						}
						actor.dir = 3
						break;
					case "Left":
						if(mapEngine.boundaryCheck(actor.x-1,actor.y, actor.z)){
							if( mapEngine.collisionCheck(actor.x-1,actor.y, actor.z,actor)){
								oldX = actor.x
								actor.x--;
								mapEngine.transposeAtom(oldX,actor.y,actor.z,actor)
							}
							else{
								
							}
						}
						else{
							if(wrap){
								if(mapEngine.boundaryCheck(mapEngine.map.length-1, actor.y, actor.z)){
									if(mapEngine.collisionCheck(mapEngine.map.length-1, actor.y, actor.z,actor)){
										oldX = actor.x
										actor.x=mapEngine.map.length-1;
										mapEngine.transposeAtom(oldX,actor.y,actor.z,actor)
									}
								}
							}
						}
						actor.dir = 4
						break;
					case "Right":
						if(mapEngine.boundaryCheck(actor.x+1,actor.y, actor.z)){
							if(mapEngine.collisionCheck(actor.x+1,actor.y, actor.z,actor)){
								oldX = actor.x
								actor.x++;
								mapEngine.transposeAtom(oldX,actor.y,actor.z,actor)
							}
						}
						else{
							if(wrap){
								if(mapEngine.boundaryCheck(0, actor.y, actor.z)){
									if(mapEngine.collisionCheck(0, actor.y, actor.z,actor)){
										oldX = actor.x
										actor.x=0;
										mapEngine.transposeAtom(oldX,actor.y,actor.z,actor)
									}
								}
							}
						}
						actor.dir = 2
						break;	
					}
				}
			}
		}
		class JSGEmapEngine{
			//Set the scale factor and initiate the draw loop
			constructor(){		
				
			}
			getMousePos(canvas, evt) {
				var rect = canvas.getBoundingClientRect();
				return {
				  x: evt.clientX - rect.left,
				  y: evt.clientY - rect.top
				};
			}
			distanceCheck(focuspt,x,y){
				return new Array((x-focuspt.x),(y-focuspt.y))
			}
			loadMap(map){
				this.map = map
				this.self = this
				tileMap.WScale = tileMap.Width * scale;
				tileMap.HScale = tileMap.Height * scale;
				tileMap.canvasHeight= tileMap.HScale * viewportHeight;
				tileMap.canvasWidth = tileMap.WScale * viewportWidth;
				c.width = tileMap.canvasWidth;
				c.height = tileMap.canvasHeight;
				this.mapHalfH = (tileMap.HScale)/2
				this.mapHalfW = (tileMap.WScale)/2
				this.transformW = ((c.width)/2)
				this.transformH = ((c.height)/2)
				ctx.translate(this.transformW-this.mapHalfW,this.transformH-this.mapHalfH)
			}
			//First step of drawing a frame - pull the rows and draw each row
			startDraw(){
				this.drawLoop = setInterval(this.drawMap, drawDelay, this.self);
			}
			pauseDraw(){
				clearInterval(this.drawLoop)
			}
			drawMap(self){
				var i = 0;
				actorEngine.actorStatus=""
				while(i<self.map.length){
					if((typeof self.map[i]) != "undefined" && self.map[i] != null ){
						self.drawRow(self.map[i], i);
					}
					i++;
				}
				i=0
				while(i<actorEngine.actors.length){			
					if(actorEngine.actors[i].getActorInfo != null){
						actorEngine.actorStatus +=actorEngine.actors[i].getActorInfo()
					}
					if(actorEngine.actors[i].tryTick != null){
						actorEngine.actors[i].tryTick()
					}
					i++
				}
				mapEngine.writeActor(actorEngine.actorStatus)
			}
			//In each row, pull each stack and draw the stack
			drawRow(rowArr, rowIndex){
				var i = 0;
				while(i<rowArr.length){
					if((typeof rowArr[i]) != "undefined" && rowArr[i] != null ){
						this.drawStack(rowArr[i],i, rowIndex);
						
					}
					i++;
				}
			}
			//in each stack, draw the atoms from lowest to highest
			drawStack(colArr, colIndex, rowIndex){
				var i = 0;
				while(i<colArr.length){
					if((typeof colArr[i]) != "undefined" && colArr[i] != null ){
						var curTile = tileMap.namedTiles[colArr[i].tile]
						var curDistance
						var curX = tileMap.HScale * rowIndex
						var curY = tileMap.WScale * colIndex
						if(actorEngine.player != null){
							curDistance = this.distanceCheck(actorEngine.player, rowIndex, colIndex)
							curX = tileMap.HScale * curDistance[0]
							curY = tileMap.WScale * curDistance[1]					
						}
						if((Math.abs(curX/tileMap.HScale)<(viewportWidth/2))&&(Math.abs(curY/tileMap.WScale)<(viewportHeight/2))){
							this.drawTile(curTile, curX, curY)
						}
						if(colArr[i].getClass!=null){
							if((typeof colArr[i].doMapTick) != "undefined"){
								colArr[i].doMapTick(rowIndex,colIndex)
							}
							if(colArr[i].getClass() == "Player"){
								this.writeDebug(colArr[i].lastKey) 
							}
						}
					}
					i++;
				}
			}
			//draw the tile associated with the atom at the respective location
			drawTile(tilePoint,x,y){  
			  ctx.drawImage(tileMap.img,tilePoint[0], tilePoint[1],tileMap.Width,tileMap.Height,x,y,tileMap.WScale, tileMap.HScale);
			}
			destroyAtom(x,y,z){
				this.map[x][y][z]=null
			}
			spawnAtom(x,y,z,atom){
				this.map[x][y][z]=atom}
			transposeAtom(x,y,z,atom){
				this.map[x][y][z]=null
				this.map[atom.x][atom.y][atom.z]=atom
			}
			//Check if the target is occupied
			collisionCheck(x,y,z,actor){
				if ((typeof this.map[x]) != "undefined" ){
					if((typeof this.map[x][y]) != "undefined"){
						if((typeof this.map[x][y][z]) != "undefined"){
							if ((this.map[x][y][z]) == null){
								if(this.map[x][y][z+1] != null){
									if(this.map[x][y][z+1].collisionAction != null){
										this.map[x][y][z+1].collisionAction(x,y,z,actor)
									}
								}
								return true;					
							}
							else{
								actor.collisionAction(x,y,z,this.map[x][y][z])
								if(this.map[x][y][z].health < 0){
									this.map[x][y][z].deathAction()
								}
								return false					
							}
						}
						else{
							return false
						}
					}
					else{
						return false
					}
				}
				else{
					return false
				}
			}
			//check if the target is in bounds
			boundaryCheck(x, y, z){
				if ((typeof this.map[x]) != "undefined" ){
					if((typeof this.map[x][y]) != "undefined"){			
						if((typeof this.map[x][y][z]) != "undefined"){			
							return true;
						}
						else{
							return false
						}
					}
					else{
						return false
					}
				}
				else{
					return false
				}
			}
			writeDebug(msg){
				debugElem.innerHTML = msg
			}
			writeActor(msg){
				actorElem.innerHTML = msg
			}
		}


		/////	ATOM CLASS DEFINITIONS			/////
		class Atom{
			//The base type for any "thing" in the game world
			constructor(x,y,z,dir,tile,collisionLayers){
				this.collisionLayers = new Array();
				this.x = x;
				this.y = y;
				this.z = z;
				this.dir = dir;
				this.tile = tile;	
				this.self = this
				if(collisionLayers == null){
					collisionLayers = new Array()
				}
				this.collisionLayers = collisionLayers;
			}
			boundaryAction(BoundX, BoundY){}
			collisionAction(ColX, ColY, ColZ, ColActor){
				var actorClass = ColActor.getClass()
				var selfClass = this.getClass()
				console.log(selfClass + " collided with " + actorClass)
			}
			getClass(){
				return this.__proto__.constructor.name
			}
		}
		class Tile extends Atom{
			//The base type for environmental tiles (walls, floors, etc)
			constructor(x,y,z,dir,tile,collisionLayers){
				super(x,y,z,dir,tile,collisionLayers)
				this.collisionLayers.push("Tile")
			}

		}
		class Item extends Atom{
			//The base type for items (can be picked up and used, moves between inventory and gameworld)
			constructor(x,y,z,dir,tile,collisionLayers,stack){
				super(x,y,z,dir,tile,collisionLayers)
				this.collisionLayers.push("Item")
				this.stack = stack
			}
			fireAction(){}
			pickupAction(){}
		}
		class Actor extends Atom{
			//Base type for an actor (represents an active entity with related properties like health)
			constructor(x,y,z,dir,tile,collisionLayers,health,damageModifier, baseDamage, tick){
				super(x,y,z,dir,tile,collisionLayers)
				this.health = health;
				this.maxHealth = health;
				this.mana = 100;
				this.maxMana = this.mana;
				this.damageModifier = damageModifier;
				this.baseDamage = baseDamage;
				this.collisionLayers.push("Actor");
				this.tick = tick
				this.tickCycle= 0;
				this.inventory = new Array();
				this.canMove = true;
				this.canInfo = true;
			}
			pickup(item){
				if(item.collisionLayers.find(function(element) {return element == "Item";}) != null){
					this.inventory.push(item)
					item.pickupAction()
					item.x=-1;
					item.y=-1;
					destroyAtom(item)
					switch(this.dir){
						case 1:
							actorEngine.doMove(new Array("Up"),this)
							break;
						case 2:
							actorEngine.doMove(new Array("Right"),this)					
							break;	
						case 3:
							actorEngine.doMove(new Array("Down"),this)					
							break;
						case 4:
							actorEngine.doMove(new Array("Left"),this)					
							break;
					}
					return true;
				}
				else{
					return false
				}
			}
			initAuto(self){
				//self.tickCycle = setInterval(self.tickAction, self.tick, self);
			}
			tryTick(){
				this.tickCycle++
				if(this.tickCycle > (this.tick/drawDelay)){
					this.tickAction(this)
					this.tickCycle = 0
				}
			}
			collisionAction(ColX, ColY, ColZ, ColActor){
				var actorClass = ColActor.getClass()
				var selfClass = this.getClass()
				console.log(selfClass + " collided with " + actorClass)
				if(!this.pickup(ColActor)&&ColActor.takeDamage!=null){
					ColActor.takeDamage(this.baseDamage)			
				}
			}
			takeDamage(damage){
				this.health += 0-(damage*this.damageModifier)
				if(this.health<0){
					this.deathAction()
				}
				if(this.health>this.maxHealth){
					this.health=this.maxHealth
				}
			}
			takeManaDamage(damage){
				this.mana += 0-(damage*this.damageModifier)
				if(this.mana<0){
					this.mana=0
				}
				if(this.mana>this.maxMana){
					this.mana=this.maxMana
				}
			}
			tickAction(self){		
				console.log ((self.getClass())+" Ticked")
			}
			fireAction(x,y){
				console.log ((this.getClass())+" Fired")
			}
			jumpAction(newZ) {
				console.log ((this.getClass())+" Jumped")
			}
			moveAction(moveDir) {
				console.log ((this.getClass())+" Moved")
			}
			deathAction(){
				clearInterval(this.interval)
				
				mapEngine.destroyAtom(this.x,this.y,this.z,this)
				this.x=-1;
				this.y=-1;
				this.z=-1;
				console.log ((this.getClass())+" Died")
			}
			getActorInfo(){		
				if(this.canInfo==true){
					return "["+this.getClass()+"]<br>Health:"+Math.floor(this.health)+" - Dir:"+this.dir+" - Mana:"+Math.floor(this.mana)+"<br><br>"
				}
				else{
					return ""
				}
			}
		}
		class Player extends Actor{

			//Base type for a player - also binds keyset
			constructor(x,y,z,dir,tile,collisionLayers,health,damageModifier,keys,baseDamage){
				super(x,y,z,dir,tile,collisionLayers,health,damageModifier, baseDamage,1000)
				this.collisionLayers.push("Player")
				this.keys = keys
				this.lastKey=new Array("null",0)
				this.self = this
			}
			deathAction(){
				mapEngine.destroyAtom(this.x,this.y,this.z,this)
				this.x=-1;
				this.y=-1;
				this.z=-1;
				console.log ((this.getClass())+" Died")
			}
		}


	</script>
	<script id="EngineConfig.\">
		/*///////PLANNING//////////
		//
		//
		// 4 spells - earth air fire water
		// 
		// water extinguishes fire, captures occupant
		// fire consumes air, burns occupants
		// air moves earth and actors, direction chosen by random if even, max if odd
		// earth blocks a tile, lifts occupant
		//
		// langton-ant the enemies, with a shared floor. Player direction applies color change
		//
		//
		/////////PLANNING////////*/


		//Classes
		//Base Atom is meant to be generic as all hell. As such, extended classes for tile types and item types shouldn't be defined there. The Engine Config is meant to sit on top of the mapengine and atom to create the rest of the game logic from those parts.

		class Floor extends Tile{
			constructor(x,y){
				super(x,y,0,0,"floor",null)
				this.collisionLayers.push("Floor")
			}	
		}
		class Wall extends Tile{
			constructor(x,y){
				super(x,y,1,0,"wall",null)
			}	
		}
		class Wand extends Item{
			constructor(x,y, f){
				super(x,y,1,1,"wand",null,1)
				this.flag=f
				
			}
			
		}
		class Slime extends Actor{
			constructor(x,y,z,dir,tick){
				super(x,y,z,dir,"slime",new Array(),60,0.8,20,(tick*0.8))
				this.collisionLayers.push("Slime");
				this.oldColAct = this.collisionAction
				this.collisionAction=this.newCollisionAction
				this.recovery = 0.9
			}
			newCollisionAction(ColX,ColY,ColZ,ColActor){
				this.oldColAct(ColX,ColY,ColZ,ColActor)
				if(!this.pickup(ColActor)&&ColActor.takeDamage!=null){
					this.takeDamage(0-this.baseDamage*this.recovery)			
				}
				
			}
		}
		class FireWand extends Wand{
			
			constructor(x,y){
				super(x,y,2)
			}
			fireAction(actor, mana,x, y){
				var newX = x;
				var newY = y;
				/* switch(actor.dir){
					case 1:
						newY--;
						newY--;
						break;
					case 2:
						newX++;
						newX++;
						break;
					case 3:
						newY++;
						newY++;
						break;
					case 4:
						newX--;
						newX--;
						break;
				}		 */
				mapEngine.spawnAtom(newX,newY,2,fireField)
				drawLifeTile(newX,newY,fieldMap,this.flag)
			}
			dropAction(actor){
				this.x=actor.x;
				this.y=actor.y;
				spawnAtom(actor.x,actor.y,actor.z, this)
			}
		}
		class WaterWand extends Wand{
			
			constructor(x,y){
				super(x,y,1)
			}
			fireAction(actor, mana,x,y){
				var newX = x;
				var newY = y;
				/* switch(actor.dir){
					case 1:
						newY--;
						newY--;
						break;
					case 2:
						newX++;
						newX++;
						break;
					case 3:
						newY++;
						newY++;
						break;
					case 4:
						newX--;
						newX--;
						break;
				}		 */
				mapEngine.spawnAtom(newX,newY,2,fireField)
				drawLifeTile(newX,newY,fieldMap,this.flag)
			}
			dropAction(actor){
				this.x=actor.x;
				this.y=actor.y;
				spawnAtom(actor.x,actor.y,actor.z, this)
			}
		}
		class EarthWand extends Wand{
			
			constructor(x,y){
				super(x,y,8)
			}
			fireAction(actor, mana,x,y){
				var newX = x;
				var newY = y;
				mapEngine.spawnAtom(newX,newY,2,fireField)
				drawLifeTile(newX,newY,fieldMap,this.flag)
			}
			dropAction(actor){
				this.x=actor.x;
				this.y=actor.y;
				spawnAtom(actor.x,actor.y,actor.z, this)
			}
		}
		class AirWand extends Wand{
			
			constructor(x,y){
				super(x,y,4)
			}
			fireAction(actor, mana,x,y){
				var newX = x;
				var newY = y;
				mapEngine.spawnAtom(newX,newY,2,fireField)
				drawLifeTile(newX,newY,fieldMap,this.flag)
			}
			dropAction(actor){
				this.x=actor.x;
				this.y=actor.y;
				spawnAtom(actor.x,actor.y,actor.z, this)
			}
		}
		class LifeEntity extends Actor{
			//The base type for items (can be picked up and used, moves between inventory and gameworld)
			constructor(tile){
				//x,y,z,dir,tile,collisionLayers,health,damageModifier, baseDamage, tick
				super(-1,-1,2,1,tile,null,9999999,0,10,1000)
				this.collisionLayers.push("LifeEntity")
				this.canInfo=false;
				this.canMove=false;
			}
			doMapTick(i,j){
				lifeDamageTickDelay++;
				lifeTickCount++;
				if((lifeDamageTickDelay / lifeDamageTickTime) > 1){
					lifeDamageTickDelay = 1;
					if(mapEngine.map[i][j][1]!= null){
						this.doMagic(mapEngine.map[i][j][1])
					}			
				}		
			}
			tryTick(){		
				lifeTickCount++;
				if((lifeTickCount > (lifeSpeed/drawDelay))){
					lifeDraw()
					lifeTickCount = 0
				}
			}
			doMagic(actor){		
				console.log(this.getClass()+" ticked at "+i+" : "+j+" on obj "+actor.getClass())
			}
			collisionAction(x,y,z,actor){
				this.doMagic(actor)
			}
		}
		class EarthField extends LifeEntity{
			//The base type for items (can be picked up and used, moves between inventory and gameworld)
			constructor(){
				//x,y,z,dir,tile,collisionLayers,health,damageModifier, baseDamage, tick
				super("earth")
				this.flag = 8;
			}
			doMagic(actor){
				
				if(actor!= null){
					if(actor.canMove != null){
						actor.canMove = false
					}	
				}
			}
		}
		class AirField extends LifeEntity{
			//The base type for items (can be picked up and used, moves between inventory and gameworld)
			constructor(){
				//x,y,z,dir,tile,collisionLayers,health,damageModifier, baseDamage, tick
				super("air")
				this.flag = 4;
			}
			doMagic(actor){		
				if(actor!= null){
					if(actor.canMove != null){
						switch(getRdm(0,4)){
							case 0:	actorEngine.doMove(new Array("Up"), actor); break;
							case 1:	actorEngine.doMove(new Array("Down"), actor); break;
							case 2:	actorEngine.doMove(new Array("Left"), actor); break;
							case 3:	actorEngine.doMove(new Array("Right"), actor); break;
						}
					}	
				}
			}
			
		}
		class FireField extends LifeEntity{
			//The base type for items (can be picked up and used, moves between inventory and gameworld)
			constructor(){
				//x,y,z,dir,tile,collisionLayers,health,damageModifier, baseDamage, tick
				super("fire")
				this.flag = 2;
			}
			doMagic(actor){		
				if((typeof actor.health) == "number"){
					console.log(actor.health + "health")
					actor.takeDamage(100*lifeDamageTickFactor)
				}				
			}
		}
		class WaterField extends LifeEntity{
			//The base type for items (can be picked up and used, moves between inventory and gameworld)
			constructor(){
				//x,y,z,dir,tile,collisionLayers,health,damageModifier, baseDamage, tick
				super("water")
				this.flag = 1;
			}
			doMagic(actor){		
				if((typeof actor.health) == "number"){
					console.log(actor.health + "health")
					actor.takeDamage(-5*lifeDamageTickFactor)
					actor.takeManaDamage(-10*lifeDamageTickFactor)
				}				
			}
		}

		//It's nice to be able to enumerate by type as well, so lets make some helper objects for that
		var rays = new Array()
		var walls = new Array()
		var floors = new Array()
		//UI current Card
		var currentCard = "";
		//DOM references
		var debugElem=document.getElementById("debugInfo");
		var actorElem=document.getElementById("actorInfo");
		var c = document.getElementById("myCanvas");
		var ctx = c.getContext("2d");
		//Player and field maps
		var player = null;
		var fieldMap = new Array()
		var fireField = new FireField()
		var waterField = new WaterField()
		var earthField = new EarthField()
		var airField = new AirField()
		//Base Parameters
		var scale = 1;
		var drawDelay = 50;
		var wrap = true;
		var mapWidth = 40;
		var mapHeight= 40;
		var viewportHeight=25;
		var viewportWidth=25;
		var mapDepth = 3;
		var dirVariance = 1;
		var minEnemies = 10;
		var maxEnemies = 20;
		var enemyTickSpeed = 1000;
		var lifeDamageTickTime = 11;
		var lifeDamageTickFactor = 0.1
		var lifeSpeed = 10000;
		var lifeSpeedH = 10000;
		var lifeSpeedStep = 5;
		var lifeSpeedL = 10;
		var lifeTickCount = 0;
		var lifeDamageTickDelay = 1;
		//Define the engines
		var mapEngine = null
		var actorEngine = null
		//TileMap definition (how do we chop up the image into separate tiles?)
		var tileMap = {
			Width:30,
			Height:30,
			WScale:0,
			HScale:0,
			canvasWidth:0,
			canvasHeight:0,
			img : document.getElementById("tileset"),
			namedTiles : {
				"floor" : new Array(0,0),
				"wall" : new Array(30,0),
				"earth" : new Array(60,0),
				"air" : new Array(90,0),
				"fire" : new Array(120,0),
				"water" : new Array(150,0),
				"slime": new Array(30,30),
				"player": new Array(60,30),
				"pointer": new Array(80,0)
			}
		};
		//Define the default keyset (keycode: action, actiontype)
		var keys = {
			/*
			[<-37][A-38][>-39][V-40]
			[space-32][ctrl-17][shift-16][alt-18]
			[z-90][x-88][c-67]
			[a-65][s-83][d-68]
			[q-81][w-87][e-69]
			[del-46][end-35][pgdwn-34]
			[ins-45][home-36][pgup-33]
			*/
			38:new Array("Up", "PlayerMovement"),
			40:new Array("Down", "PlayerMovement"),
			37:new Array("Left", "PlayerMovement"),
			39:new Array("Right", "PlayerMovement"),
			32:new Array("Jump", "PlayerMovement"),
			46:new Array("Fire", "PlayerAction"),
			45:new Array("NextMenu", "UIAction"),
			45:new Array("PrevMenu", "UIAction"),
			34:new Array("NextItem", "UIAction"),
			33:new Array("PrevItem", "UIAction"),
			45:new Array("Select", "UIAction"),
			16:new Array("Mod1", "Modifier",0),
			17:new Array("Mod2", "Modifier",0),
			18:new Array("Mod3", "Modifier",0),
			
		}
			
		window.addEventListener('keyup',checkUp,false);
		window.addEventListener('keyup',checkDown,false);
		c.addEventListener('mousemove', function(evt) {
			mapEngine.mousePos = mapEngine.getMousePos(c, evt);
			
		}, false);	  
		c.addEventListener('click', function(e) {
			var normalX = (mapEngine.mousePos.x - tileMap.canvasWidth/2)
			var normalY = (mapEngine.mousePos.y - tileMap.canvasHeight/2)
			var normalPercentX = normalX/(tileMap.canvasWidth/2)
			var normalPercentY = normalY/(tileMap.canvasHeight/2)
			var spellX = Math.floor(normalPercentX*(viewportWidth/2)+0.5)+actorEngine.player.x
			var spellY = Math.floor(normalPercentY*(viewportHeight/2)+0.5)+actorEngine.player.y	
			actorEngine.player.fireAction(spellX,spellY)
			
		}, 0);
		function checkUp(e) {
			actorEngine.player.lastKey = keys[e.keyCode];
			console.log(e.keyCode+" Pressed")
			if(actorEngine.player.keys[e.keyCode][1]=="PlayerMovement"){
				actorEngine.doMove(actorEngine.player.keys[e.keyCode], actorEngine.player)
			}
			if(actorEngine.player.keys[e.keyCode][1]=="PlayerAction"){
				if(actorEngine.player.keys[e.keyCode][0]=="Fire"){
					var p = actorEngine.player
					var newX = actor.x;
					var newY = actor.y;
					switch(actor.dir){
						case 1:
							newY--;
							newY--;
							break;
						case 2:
							newX++;
							newX++;
							break;
						case 3:
							newY++;
							newY++;
							break;
						case 4:
							newX--;
							newX--;
							break;
					}		

					p.fireAction(newX,newY);
				}
				else{
					actorEngine.doAction(actorEngine.player.keys[e.keyCode], actorEngine.player)
				}
			}
			if(actorEngine.player.keys[e.keyCode][1]=="UIAction"){
				switch(actorEngine.player.keys[e.keyCode][0]){
					case "NextItem":
						actorEngine.player.inventory.push(actorEngine.player.inventory.shift())
						break;
					case "PrevItem":
						actorEngine.player.inventory.unshift(actorEngine.player.inventory.pop())
						break;
				}
			}
		}
		function checkDown(e) {
			actorEngine.player.lastKey = actorEngine.player.keys[e.keyCode];
			if(actorEngine.player.keys[e.keyCode][1]=="Modifier"){
				//actorEngine.doMove(actorEngine.player.keys[e.keyCode], actorEngine.player)
			}
			if(actorEngine.player.keys[e.keyCode][1]=="PlayerAction"){
				//actorEngine.doAction(actorEngine.player.keys[e.keyCode], actorEngine.player)
			}
		}

		//Initiate the engine - create the automap (as a demo) then initiate the Map Engine to start the draw loop
		function initEngines(){
			actorEngine = new JSGEactorEngine()
			mapEngine = new JSGEmapEngine()

			
			
		}

		function loadLevel(loadedMap){
			mapEngine.loadMap(loadedMap)
		}

		function flipSection(id){
			elem = document.getElementById(id)
			if (elem.style["display"]=="none"){
				elem.style = 'display:default'
			}
			else{
				elem.style = 'display:none'
			}
		}

		function lifeTick(){
			var i= 0;
			lifeSpeed = lifeSpeedH
			var newMap = new Array();
			var pattern = new Array(
				new Array(-1,-1),
				new Array(-1,0),
				new Array(-1,1),
				new Array(0,-1),
				new Array(0,1),
				new Array(1,-1),
				new Array(1,0),
				new Array(1,1)
			)
			while (i<fieldMap.length){
				var j = 0;
				newMap.push(new Array())
				while(j<fieldMap[i].length){
					var earthNb = 0;
					var airNb = 0;
					var fireNb = 0;
					var waterNb = 0;
					var k = 0;
					newMap[i].push(0);
					while(k < pattern.length){
						if(fieldMap[i+pattern[k][0]] != null){
							earthNb += (fieldMap[i+pattern[k][0]][j+pattern[k][1]] == 8)
							airNb += (fieldMap[i+pattern[k][0]][j+pattern[k][1]] == 4)
							fireNb += (fieldMap[i+pattern[k][0]][j+pattern[k][1]] == 2)
							waterNb += (fieldMap[i+pattern[k][0]][j+pattern[k][1]] == 1)
						}
						k++
					}			
					if(mapEngine.map[i][j][1]!= null){
						if(mapEngine.map[i][j][1].canMove != null){
							mapEngine.map[i][j][1].canMove = true
						}	
					}
					breedCell(newMap, 1, i, j, waterNb, 2,8);
					breedCell(newMap, 2, i, j, fireNb, 4,1);		
					breedCell(newMap, 4, i, j, airNb, 8,2);
					breedCell(newMap, 8, i, j, earthNb, 1,4);	
					if(newMap[i][j]==-1){
						newMap[i][j]=0
					}
					j++
				}
				i++
			}
			return newMap
		}
		function breedCell(newMap, flag,i,j,nb,negation,negator){	
				if(mapEngine.map[i][j][1]!==null){
					if(mapEngine.map[i][j][1].getClass() == "Wall"){
						newMap[i][j] = -1
					}
				}
				if(fieldMap[i][j] == flag){
					switch(nb){
						case 2:
						case 3:
							if((newMap[i][j] == negation || newMap[i][j] == 0)){
								
								newMap[i][j] = flag
								lifeSpeed = lifeSpeed - lifeSpeedStep
								if(lifeSpeed<lifeSpeedL){
									lifeSpeed = lifeSpeedL
								}
							}
							else{
								newMap[i][j] = -1
							}
							break;
						default:
					}
				}
				else if (fieldMap[i][j] == 0 || fieldMap[i][j] == null){				
					switch(nb){
						case 3:
							if(newMap[i][j] == negation || newMap[i][j] == 0){
								newMap[i][j] = flag
								lifeSpeed = lifeSpeed - lifeSpeedStep
								if(lifeSpeed<lifeSpeedL){
									lifeSpeed = lifeSpeedL
								}
							}
							else if(newMap[i][j] != negator){
								newMap[i][j] = -1
								
							}
							break;
						default:
					}
				}
			}
		function lifeDraw(){
			fieldMap = lifeTick()
			var i = 0;
			while(i<mapEngine.map.length){
				var j = 0
				while(j<mapEngine.map[i].length){
					switch(fieldMap[i][j]){
					case 8:
						mapEngine.spawnAtom(i,j,2,earthField)
						if(mapEngine.map[i][j][1]!=null){
							mapEngine.map[i][j][2].doMagic(mapEngine.map[i][j][1])
						}
						break;
					case 4:
						mapEngine.spawnAtom(i,j,2,airField)
						if(mapEngine.map[i][j][1]!=null){
							mapEngine.map[i][j][2].doMagic(mapEngine.map[i][j][1])
						}
						break;
					case 2:
						mapEngine.spawnAtom(i,j,2,fireField)
						if(mapEngine.map[i][j][1]!=null){
							mapEngine.map[i][j][2].doMagic(mapEngine.map[i][j][1])
						}
						break;
					case 1:
						mapEngine.spawnAtom(i,j,2,waterField)
						if(mapEngine.map[i][j][1]!=null){
							mapEngine.map[i][j][2].doMagic(mapEngine.map[i][j][1])
						}
						break;
						
					default:
						mapEngine.destroyAtom(i,j,2,earthField)
					}
					j++;
				}
				i++;
			}
		}
		function lifeInit(){
			var i = 0;
			var mapBucket = new Array();
			while(i<mapWidth){
				var rowBucket = new Array();
				var j = 0;
				while(j<mapHeight){
					rowBucket.push(null)
					j++;
				}	
				mapBucket.push(rowBucket)
				i++;
			}
			fieldMap = mapBucket;
			/*
			drawLifeTile(5,5,fieldMap,1)
			drawLifeTile(5,6,fieldMap,1)	drawLifeTile(5,7,fieldMap,1)
			drawLifeTile(7,6,fieldMap,1)
			drawLifeTile(9,5,fieldMap,1)
			drawLifeTile(9,6,fieldMap,1)
			drawLifeTile(9,7,fieldMap,1)
			
			drawLifeTile(5,9,fieldMap,8)
			drawLifeTile(5,10,fieldMap,8)
			drawLifeTile(5,11,fieldMap,8)
			drawLifeTile(7,10,fieldMap,8)
			drawLifeTile(9,9,fieldMap,8)
			drawLifeTile(9,10,fieldMap,8)
			drawLifeTile(9,11,fieldMap,8)	
			
			drawLifeTile(13,5,fieldMap,2)
			drawLifeTile(13,6,fieldMap,2)
			drawLifeTile(13,7,fieldMap,2)
			drawLifeTile(15,6,fieldMap,2)
			drawLifeTile(17,5,fieldMap,2)
			drawLifeTile(17,6,fieldMap,2)
			drawLifeTile(17,7,fieldMap,2)
			
			drawLifeTile(13,9,fieldMap,4)
			drawLifeTile(13,10,fieldMap,4)
			drawLifeTile(13,11,fieldMap,4)
			drawLifeTile(15,10,fieldMap,4)
			drawLifeTile(17,9,fieldMap,4)
			drawLifeTile(17,10,fieldMap,4)
			drawLifeTile(17,11,fieldMap,4)
			*/
		}
		function drawLifeTile(i,j,map, type) {
			map[i][j] = type
			switch(map[i][j]){
				case 8:
					mapEngine.spawnAtom(i,j,2,earthField)
					break;
				case 4:
					mapEngine.spawnAtom(i,j,2,airField)
					break;
				case 2:
					mapEngine.spawnAtom(i,j,2,fireField)
					break;
				case 1:
					mapEngine.spawnAtom(i,j,2,waterField)
					break;
					
				default:
					mapEngine.destroyAtom(i,j,2,earthField)
			}
		}

		function initGame(){
			initEngines()	
			Actor.prototype.fireAction = function fireAction(x,y){
				this.manacost = 1
				if(this.inventory[0]!=null)
					if(typeof this.inventory[0] !="undefined"){
						if(this.mana>this.manacost){
							this.inventory[0].fireAction(this, this.manacost,x,y)
							this.mana=this.mana-this.manacost
						}
					}
					
			}
			//generate Actors
			actorEngine.player = new Player(1,1,1,3,"player",null,100,1,keys,10)
			actorEngine.actors.push(earthField)
			actorEngine.actors.push(fireField)
			actorEngine.actors.push(airField)
			actorEngine.actors.push(waterField)	
			actorEngine.actors.push(actorEngine.player)
			actorEngine.player.mana = 100
			actorEngine.player.inventory.push(new FireWand(-1,-1))
			actorEngine.player.inventory.push(new WaterWand(-1,-1))
			actorEngine.player.inventory.push(new AirWand(-1,-1))
			actorEngine.player.inventory.push(new EarthWand(-1,-1))
			loadLevel(mapAutoGen())
			lifeInit()
			//setInterval(lifeDraw,lifeSpeed)
			mapEngine.startDraw()
			var i = 0
			
			while(i < (getRdm(minEnemies,maxEnemies))){
				var newX = getRdm(1,mapWidth-1);
				var newY = getRdm(1,mapHeight-1);
				if (newX != actorEngine.player.x && newY != actorEngine.player.y){
					var newEnemy = new Slime(newX,newY,1,1,enemyTickSpeed);
					newEnemy.tickAction = AIMove;
					//newEnemy.initAuto(newEnemy);
					actorEngine.enemies.push(newEnemy);
					actorEngine.actors.push(newEnemy);
				}
				else{
					i--;
				}
				i++;
			}
			
			var i = 0;
			while(i<actorEngine.actors.length){
				var p = actorEngine.actors[i];
				mapEngine.spawnAtom(p.x,p.y,p.z,p);
				i++;
			}
		}

		function getRdm(min, max){
			return (Math.floor(Math.random()*(max-min))+min)
		}

		function mapAutoGen(){	
		var i = 0;
		var mapBucket = new Array();
		while(i<mapWidth){
			var rowBucket = new Array();
			var j = 0;
			while(j<mapHeight){
				var depthBucket = new Array();
				var k = 0;
				while(k<mapDepth){
					if(k==0){
						depthBucket.push(new Floor(i, j))
					}
					else if((j == 0 || i == 0 || (i==5&&j<20) || (i==10&&j>20)) && k == 1){		
						depthBucket.push(new Wall(i, j))
					}
					else if((j == mapHeight-1 || i == mapWidth-1) && k == 1){
						depthBucket.push(new Wall(i, j))
					}
					else{	
						var l = 0
						var actorFound = null
						while (l < actorEngine.actors.length){					
							if(i == actorEngine.actors[l].x && j == actorEngine.actors[l].y && k==1){
								actorFound = actorEngine.actors[l]
							}	
							l++;
						}
						depthBucket.push(actorFound)
					}
					k++;
				}
				rowBucket.push(depthBucket)
				j++;
			}
			
			mapBucket.push(rowBucket)
			i++;
		}
		return mapBucket
		}

		function AIMove(self){
			var targetX = actorEngine.player.x
			var targetY = actorEngine.player.y
			var targetZ = actorEngine.player.z
			var currentX = self.x
			var currentY = self.y
			var currentZ = self.z
			var newDir = new Array();
			if(getRdm(1,10) > dirVariance){
				if(targetZ == currentZ){
					var difX = currentX - targetX
					var difY = currentY - targetY
					if(Math.abs(difX)>Math.abs(difY)){
						if(difX>0){
							newDir.push("Left")
						}
						else if(difX<0){
							newDir.push("Right")
						}
					}
					else{
						if(difY>0){
							newDir.push("Up")
						}
						else if(difY<0){
							newDir.push("Down")
						}			
					}
				}
			}
			else{
				switch(getRdm(1,5)){
					case 1:
						newDir.push("Up")
						break;
					case 2:
						newDir.push("Right")
						break;
					case 3:
						newDir.push("Down")
						break;
					case 4:
						newDir.push("Left")
						break;		
				}
			}
			actorEngine.doMove(newDir, self)
		}

		function openCard(id){			
			var elem=document.getElementById(id)
			if (elem.style["visibility"]=="collapse" || elem.style["visibility"] == ""){
				if(currentCard !=""){
					openCard(currentCard)
					}
				elem.style["visibility"]='visible'
				currentCard = id
				}
			else{
				currentCard = ""
				elem.style["visibility"]='collapse'
			}
		}



	</script>
</body>
</html>